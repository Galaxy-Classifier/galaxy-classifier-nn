# -*- coding: utf-8 -*-
"""autoencoder.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zGBdDdLPXVv0iVGwzVs5sLG_IRBGLPxw
"""
from __future__ import absolute_import # Added to make compatbile with python 3
from __future__ import division # Added to make compatbile with python 3

from google.colab import drive
drive.mount('/content/datasets',force_remount=True)

import glob

import cv2
import keras
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image
from keras.callbacks import ModelCheckpoint, TensorBoard
from keras.layers import Input, Dense
from keras.models import Model, Sequential
from keras.models import Model, load_model
width, height = 100,100

def extract_data(path):
    data = []
    files = glob.glob(path)
    for myFile in files:
        image = cv2.imread(myFile)
        gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        im_resized = cv2.resize(gray_image, (width, height), 
                                interpolation=cv2.INTER_LINEAR)
        data.append(im_resized)

    return np.array(data)

nb_epoch = 1000
input_dim = width * height
encoding_dim = int(input_dim / 24.5) 

url_dataset = "/content/datasets/My Drive/datasetGalaxias30/Lenticular/*.jpg"
url_modelo = "/content/datasets/My Drive/datasetGalaxias70/lenticularTrain.h5"
ruta_guardado = '/content/datasets/My Drive/datasetGalaxias30/lenticularAutoencoder/lenticular'
digits_display = 5  # how many digits we will display
total_train = 11

data = extract_data(url_dataset)
test_data,train_data = np.split(data, [total_train])

autoencoder = Sequential()

# Encoder Layers
autoencoder.add(Dense(4 * encoding_dim, input_shape=(input_dim,), activation='relu'))
autoencoder.add(Dense(2 * encoding_dim, activation='relu'))
autoencoder.add(Dense(encoding_dim, activation='relu'))

# Decoder Layers
autoencoder.add(Dense(2 * encoding_dim, activation='relu'))
autoencoder.add(Dense(4 * encoding_dim, activation='relu'))
autoencoder.add(Dense(input_dim, activation='sigmoid'))

input_img = Input(shape=(input_dim,))
encoder_layer1 = autoencoder.layers[0]
encoder_layer2 = autoencoder.layers[1]
encoder_layer3 = autoencoder.layers[2]

encoder = Model(input_img, encoder_layer3(encoder_layer2(encoder_layer1(input_img))))

#train_data = train_data.astype('float32') / 255.
#train_data = train_data.reshape((len(train_data), np.prod(train_data.shape[1:])))

test_data = test_data.astype('float32') / 255.
test_data = test_data.reshape((len(test_data), np.prod(test_data.shape[1:])))

autoencoder.compile(metrics=['accuracy'],
                    loss='mean_squared_error',
                    optimizer='adam')


"""cp = ModelCheckpoint(filepath=url_modelo,
                     save_best_only=True,
                     verbose=0)

tb = TensorBoard(log_dir='./logs',
                 histogram_freq=0,
                 write_graph=True,
                 write_images=True)

keras.callbacks.EarlyStopping(monitor='val_loss',
                              min_delta=0,
                              patience=0,
                              verbose=0, mode='auto')

history = autoencoder.fit(train_data, train_data,
                          epochs=nb_epoch,
                          batch_size=256,
                          shuffle=True,
                          validation_data=(test_data, test_data),
                          verbose=1,
                          callbacks=[cp, tb]).history


plt.plot(history['loss'], linewidth=2, label='Train')
plt.plot(history['val_loss'], linewidth=2, label='Test')
plt.legend(loc='upper right')
plt.title('Model loss')
plt.ylabel('Loss')
plt.xlabel('Epoch')
plt.show()"""

autoencoder = load_model(url_modelo)

  
decoded_imgs = autoencoder.predict(test_data)


for i in range(digits_display):
    # display original
    ax = plt.subplot(2, digits_display, i + 1)
    plt.imshow(test_data[i].reshape(width, height))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)

    # display reconstruction
    ax = plt.subplot(2, digits_display, i + 1 + digits_display)
    plt.imshow(decoded_imgs[i].reshape(width, height))
    plt.gray()
    ax.get_xaxis().set_visible(False)
    ax.get_yaxis().set_visible(False)
plt.show()  

data = data.astype('float32') / 255.
data = data.reshape((len(data), np.prod(data.shape[1:])))
all_decoded_imgs = autoencoder.predict(test_data)

for j in range(len(test_data)):
    image = all_decoded_imgs[j].reshape((width, height))
    formatted = (image * 255 / np.max(image)).astype('uint8')
    img = Image.fromarray(formatted)
    img.save(ruta_guardado + str(j) + '.png')